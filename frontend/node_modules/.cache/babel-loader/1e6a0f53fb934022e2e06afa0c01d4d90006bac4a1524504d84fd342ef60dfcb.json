{"ast":null,"code":"// src/services/RecommendationService.js - UPDATED FOR TRUE ONTOLOGY INTEGRATION\nimport { getOntologyRecommendations, analyzeIngredientConflicts, getIngredientSynergies } from './api';\nclass RecommendationService {\n  constructor() {\n    this.cachedRecommendations = null;\n    this.lastProfile = null;\n    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes cache\n  }\n\n  // ================== üß† MAIN ONTOLOGY RECOMMENDATIONS ==================\n\n  /**\r\n   * Get personalized skincare recommendations using TRUE ontology-based algorithm\r\n   * @param {Object} profile - User skin profile\r\n   * @param {string} profile.skin_type - 'normal', 'dry', 'oily', 'combination'\r\n   * @param {Array} profile.concerns - ['acne', 'wrinkles', 'dryness', etc.]\r\n   * @param {Array} profile.sensitivities - ['fragrance', 'alcohol', 'silicone']\r\n   * @returns {Promise<Object>} Ontology-based recommendations\r\n   */\n  async getPersonalizedRecommendations(profile, options = {}) {\n    try {\n      var _result$metadata;\n      const {\n        useCache = true,\n        forceRefresh = false,\n        includeExplanation = true\n      } = options;\n\n      // Validate profile\n      if (!this.validateProfile(profile)) {\n        throw new Error('Invalid skin profile provided');\n      }\n\n      // Check cache (if enabled and not forced refresh)\n      if (useCache && !forceRefresh && this.isCacheValid(profile)) {\n        console.log('üì¶ Using cached ontology recommendations');\n        return this.cachedRecommendations;\n      }\n      console.log('üß† Getting fresh ontology recommendations for profile:', profile);\n\n      // Call TRUE ontology-based API\n      const startTime = Date.now();\n      const result = await getOntologyRecommendations(profile);\n      const responseTime = Date.now() - startTime;\n\n      // Process and enhance recommendations\n      const processedRecommendations = this.processOntologyRecommendations(result, profile);\n\n      // Cache results\n      if (useCache) {\n        this.cacheRecommendations(processedRecommendations, profile);\n      }\n      console.log(`‚úÖ Ontology recommendations completed in ${responseTime}ms`);\n      console.log(`üéØ Found ${processedRecommendations.recommendations.length} recommendations`);\n      return {\n        success: true,\n        ...processedRecommendations,\n        performance: {\n          frontend_processing_time: responseTime,\n          backend_processing_time: (_result$metadata = result.metadata) === null || _result$metadata === void 0 ? void 0 : _result$metadata.processing_time_ms,\n          total_recommendations: processedRecommendations.recommendations.length\n        }\n      };\n    } catch (error) {\n      console.error('‚ùå Personalized recommendations failed:', error);\n\n      // Return fallback recommendations if available\n      if (this.cachedRecommendations) {\n        console.log('üîÑ Falling back to cached recommendations');\n        return {\n          success: false,\n          fallback: true,\n          error: error.message,\n          ...this.cachedRecommendations\n        };\n      }\n      throw new Error(`Failed to get personalized recommendations: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Process raw ontology recommendations and add frontend enhancements\r\n   */\n  processOntologyRecommendations(rawResult, profile) {\n    const {\n      recommendations,\n      metadata,\n      academic_analysis\n    } = rawResult;\n\n    // Enhance each recommendation with UI-friendly data\n    const enhancedRecommendations = recommendations.map((product, index) => {\n      var _product$semantic_saf;\n      return {\n        ...product,\n        ui_enhancements: {\n          ranking: index + 1,\n          confidence_badge: this.getConfidenceBadge(product.final_ontology_score),\n          suitable_for: this.getSuitabilityText(product, profile),\n          why_recommended: this.getRecommendationReason(product, profile),\n          semantic_highlights: this.getSemanticHighlights(product),\n          safety_status: ((_product$semantic_saf = product.semantic_safety_analysis) === null || _product$semantic_saf === void 0 ? void 0 : _product$semantic_saf.overall_safety_status) || 'unknown'\n        }\n      };\n    });\n\n    // Group recommendations by category for better UX\n    const groupedByCategory = this.groupByCategory(enhancedRecommendations);\n\n    // Extract key insights for dashboard\n    const insights = this.extractInsights(enhancedRecommendations, metadata, profile);\n    return {\n      recommendations: enhancedRecommendations,\n      grouped_recommendations: groupedByCategory,\n      insights,\n      metadata: {\n        ...metadata,\n        profile_used: profile,\n        generated_at: new Date().toISOString(),\n        frontend_version: '2.0.0'\n      },\n      academic_analysis\n    };\n  }\n\n  // ================== üîç ANALYSIS HELPERS ==================\n\n  /**\r\n   * Analyze ingredient compatibility for selected products\r\n   */\n  async analyzeProductCompatibility(selectedProducts) {\n    try {\n      var _conflictAnalysis$ana, _conflictAnalysis$ana2, _conflictAnalysis$ana3;\n      if (!selectedProducts || selectedProducts.length < 2) {\n        return {\n          compatible: true,\n          message: 'Need at least 2 products to analyze compatibility'\n        };\n      }\n\n      // Extract all ingredients from selected products\n      const allIngredients = this.extractIngredientsFromProducts(selectedProducts);\n\n      // Analyze conflicts using ontology\n      const conflictAnalysis = await analyzeIngredientConflicts(allIngredients);\n\n      // Get synergies\n      const synergyAnalysis = await getIngredientSynergies();\n      return {\n        compatible: ((_conflictAnalysis$ana = conflictAnalysis.analysis) === null || _conflictAnalysis$ana === void 0 ? void 0 : (_conflictAnalysis$ana2 = _conflictAnalysis$ana.conflict_analysis) === null || _conflictAnalysis$ana2 === void 0 ? void 0 : _conflictAnalysis$ana2.total_conflicts) === 0,\n        conflict_details: (_conflictAnalysis$ana3 = conflictAnalysis.analysis) === null || _conflictAnalysis$ana3 === void 0 ? void 0 : _conflictAnalysis$ana3.conflict_analysis,\n        synergy_opportunities: this.findSynergiesInProducts(selectedProducts, synergyAnalysis),\n        recommendations: this.generateCompatibilityRecommendations(conflictAnalysis),\n        selected_products: selectedProducts.map(p => ({\n          id: p.id,\n          name: p.name,\n          brand_name: p.brand_name,\n          main_category: p.main_category\n        }))\n      };\n    } catch (error) {\n      console.error('‚ùå Product compatibility analysis failed:', error);\n      return {\n        compatible: null,\n        error: error.message,\n        selected_products: selectedProducts\n      };\n    }\n  }\n\n  /**\r\n   * Get recommendations by category with ontology insights\r\n   */\n  async getRecommendationsByCategory(category, userProfile = null) {\n    try {\n      // If user profile available, use ontology recommendations and filter by category\n      if (userProfile) {\n        const ontologyResults = await this.getPersonalizedRecommendations(userProfile);\n        const categoryRecommendations = ontologyResults.recommendations.filter(product => {\n          var _product$main_categor;\n          return ((_product$main_categor = product.main_category) === null || _product$main_categor === void 0 ? void 0 : _product$main_categor.toLowerCase()) === category.toLowerCase();\n        });\n        return {\n          success: true,\n          category,\n          recommendations: categoryRecommendations,\n          ontology_powered: true,\n          insights: ontologyResults.insights\n        };\n      }\n\n      // Fallback to generic category recommendations\n      // This would typically call a different API endpoint\n      console.log(`üìÇ Getting generic recommendations for category: ${category}`);\n      return {\n        success: true,\n        category,\n        recommendations: [],\n        ontology_powered: false,\n        message: 'Complete skin quiz for personalized ontology-based recommendations'\n      };\n    } catch (error) {\n      console.error(`‚ùå Category recommendations failed for ${category}:`, error);\n      throw error;\n    }\n  }\n\n  // ================== üõ†Ô∏è UTILITY METHODS ==================\n\n  validateProfile(profile) {\n    if (!profile || typeof profile !== 'object') return false;\n    const validSkinTypes = ['normal', 'dry', 'oily', 'combination'];\n    if (!profile.skin_type || !validSkinTypes.includes(profile.skin_type)) {\n      return false;\n    }\n\n    // Concerns and sensitivities are optional but should be arrays if provided\n    if (profile.concerns && !Array.isArray(profile.concerns)) return false;\n    if (profile.sensitivities && !Array.isArray(profile.sensitivities)) return false;\n    return true;\n  }\n  isCacheValid(profile) {\n    if (!this.cachedRecommendations || !this.lastProfile) return false;\n\n    // Check if profile changed\n    const profileChanged = JSON.stringify(profile) !== JSON.stringify(this.lastProfile);\n    if (profileChanged) return false;\n\n    // Check cache timeout\n    const cacheAge = Date.now() - this.cachedRecommendations.cached_at;\n    return cacheAge < this.cacheTimeout;\n  }\n  cacheRecommendations(recommendations, profile) {\n    this.cachedRecommendations = {\n      ...recommendations,\n      cached_at: Date.now()\n    };\n    this.lastProfile = {\n      ...profile\n    };\n    console.log('üì¶ Recommendations cached for 5 minutes');\n  }\n  getConfidenceBadge(score) {\n    if (score >= 80) return {\n      level: 'high',\n      color: 'green',\n      text: 'Highly Recommended'\n    };\n    if (score >= 60) return {\n      level: 'medium',\n      color: 'yellow',\n      text: 'Good Match'\n    };\n    if (score >= 40) return {\n      level: 'low',\n      color: 'orange',\n      text: 'Potential Match'\n    };\n    return {\n      level: 'very_low',\n      color: 'red',\n      text: 'Poor Match'\n    };\n  }\n  getSuitabilityText(product, profile) {\n    var _product$matched_sema, _product$semantic_saf2;\n    const suitableReasons = [];\n    if (((_product$matched_sema = product.matched_semantic_ingredients) === null || _product$matched_sema === void 0 ? void 0 : _product$matched_sema.length) > 0) {\n      suitableReasons.push(`Contains ${product.matched_semantic_ingredients.length} ontology-matched ingredients`);\n    }\n    if (((_product$semantic_saf2 = product.semantic_safety_analysis) === null || _product$semantic_saf2 === void 0 ? void 0 : _product$semantic_saf2.overall_safety_status) === 'safe') {\n      suitableReasons.push('Safe ingredient combination');\n    }\n    if (suitableReasons.length === 0) {\n      return `Suitable for ${profile.skin_type} skin`;\n    }\n    return suitableReasons.join(' ‚Ä¢ ');\n  }\n  getRecommendationReason(product, profile) {\n    var _product$matched_sema2;\n    const reasons = [];\n\n    // Add ontology-specific reasons\n    if (product.ontology_explanation) {\n      reasons.push(product.ontology_explanation);\n    }\n\n    // Add semantic ingredient reasons\n    if (((_product$matched_sema2 = product.matched_semantic_ingredients) === null || _product$matched_sema2 === void 0 ? void 0 : _product$matched_sema2.length) > 0) {\n      const ingredientNames = product.matched_semantic_ingredients.map(i => i.name).join(', ');\n      reasons.push(`Key ingredients: ${ingredientNames}`);\n    }\n    return reasons.length > 0 ? reasons.join(' ‚Ä¢ ') : 'Recommended by ontology algorithm';\n  }\n  getSemanticHighlights(product) {\n    const highlights = [];\n    if (product.matched_semantic_ingredients) {\n      product.matched_semantic_ingredients.forEach(ingredient => {\n        highlights.push({\n          type: 'ingredient',\n          name: ingredient.name,\n          benefit: ingredient.benefit,\n          function: ingredient.function\n        });\n      });\n    }\n    return highlights;\n  }\n  groupByCategory(recommendations) {\n    return recommendations.reduce((groups, product) => {\n      const category = product.main_category || 'Other';\n      if (!groups[category]) {\n        groups[category] = [];\n      }\n      groups[category].push(product);\n      return groups;\n    }, {});\n  }\n  extractInsights(recommendations, metadata, profile) {\n    var _profile$concerns, _profile$sensitivitie;\n    const insights = {\n      total_recommendations: recommendations.length,\n      algorithm_performance: {\n        processing_time: metadata === null || metadata === void 0 ? void 0 : metadata.processing_time_ms,\n        confidence: metadata === null || metadata === void 0 ? void 0 : metadata.ontology_confidence\n      },\n      profile_analysis: {\n        skin_type: profile.skin_type,\n        concerns_count: ((_profile$concerns = profile.concerns) === null || _profile$concerns === void 0 ? void 0 : _profile$concerns.length) || 0,\n        sensitivities_count: ((_profile$sensitivitie = profile.sensitivities) === null || _profile$sensitivitie === void 0 ? void 0 : _profile$sensitivitie.length) || 0\n      },\n      recommendation_breakdown: {},\n      top_ingredients: this.getTopIngredients(recommendations),\n      safety_overview: this.getSafetyOverview(recommendations)\n    };\n\n    // Category breakdown\n    const categoryBreakdown = this.groupByCategory(recommendations);\n    Object.keys(categoryBreakdown).forEach(category => {\n      insights.recommendation_breakdown[category] = categoryBreakdown[category].length;\n    });\n    return insights;\n  }\n  getTopIngredients(recommendations) {\n    const ingredientCount = {};\n    recommendations.forEach(product => {\n      if (product.matched_semantic_ingredients) {\n        product.matched_semantic_ingredients.forEach(ingredient => {\n          ingredientCount[ingredient.name] = (ingredientCount[ingredient.name] || 0) + 1;\n        });\n      }\n    });\n    return Object.entries(ingredientCount).sort(([, a], [, b]) => b - a).slice(0, 5).map(([name, count]) => ({\n      name,\n      frequency: count\n    }));\n  }\n  getSafetyOverview(recommendations) {\n    const safetyStatus = {\n      safe: 0,\n      warning: 0,\n      conflict: 0,\n      unknown: 0\n    };\n    recommendations.forEach(product => {\n      var _product$semantic_saf3;\n      const status = ((_product$semantic_saf3 = product.semantic_safety_analysis) === null || _product$semantic_saf3 === void 0 ? void 0 : _product$semantic_saf3.overall_safety_status) || 'unknown';\n      safetyStatus[status] = (safetyStatus[status] || 0) + 1;\n    });\n    return safetyStatus;\n  }\n  extractIngredientsFromProducts(products) {\n    const ingredients = new Set();\n    products.forEach(product => {\n      if (product.ingredient_list) {\n        // Simple ingredient extraction - could be enhanced\n        const productIngredients = product.ingredient_list.split(/[,\\n]/).map(ingredient => ingredient.trim()).filter(ingredient => ingredient.length > 0);\n        productIngredients.forEach(ingredient => ingredients.add(ingredient));\n      }\n    });\n    return Array.from(ingredients).slice(0, 20); // Limit for API performance\n  }\n  findSynergiesInProducts(products, synergyData) {\n    // Implementation would analyze synergies between products\n    // For now, return placeholder\n    return [];\n  }\n  generateCompatibilityRecommendations(conflictAnalysis) {\n    var _conflictAnalysis$ana4, _conflictAnalysis$ana5;\n    const recommendations = [];\n    if (((_conflictAnalysis$ana4 = conflictAnalysis.analysis) === null || _conflictAnalysis$ana4 === void 0 ? void 0 : (_conflictAnalysis$ana5 = _conflictAnalysis$ana4.conflict_analysis) === null || _conflictAnalysis$ana5 === void 0 ? void 0 : _conflictAnalysis$ana5.total_conflicts) > 0) {\n      recommendations.push({\n        type: 'warning',\n        message: 'Some ingredients may conflict. Consider using products at different times.',\n        action: 'Review ingredient conflicts'\n      });\n    } else {\n      recommendations.push({\n        type: 'success',\n        message: 'Products appear compatible for combined use.',\n        action: 'Safe to use together'\n      });\n    }\n    return recommendations;\n  }\n\n  // ================== üîÑ CACHE MANAGEMENT ==================\n\n  clearCache() {\n    this.cachedRecommendations = null;\n    this.lastProfile = null;\n    console.log('üóëÔ∏è Recommendation cache cleared');\n  }\n  getCacheInfo() {\n    if (!this.cachedRecommendations) {\n      return {\n        cached: false\n      };\n    }\n    const cacheAge = Date.now() - this.cachedRecommendations.cached_at;\n    const isValid = cacheAge < this.cacheTimeout;\n    return {\n      cached: true,\n      age_ms: cacheAge,\n      is_valid: isValid,\n      profile: this.lastProfile,\n      expires_in_ms: this.cacheTimeout - cacheAge\n    };\n  }\n}\n\n// Export singleton instance\nconst recommendationService = new RecommendationService();\nexport default recommendationService;","map":{"version":3,"names":["getOntologyRecommendations","analyzeIngredientConflicts","getIngredientSynergies","RecommendationService","constructor","cachedRecommendations","lastProfile","cacheTimeout","getPersonalizedRecommendations","profile","options","_result$metadata","useCache","forceRefresh","includeExplanation","validateProfile","Error","isCacheValid","console","log","startTime","Date","now","result","responseTime","processedRecommendations","processOntologyRecommendations","cacheRecommendations","recommendations","length","success","performance","frontend_processing_time","backend_processing_time","metadata","processing_time_ms","total_recommendations","error","fallback","message","rawResult","academic_analysis","enhancedRecommendations","map","product","index","_product$semantic_saf","ui_enhancements","ranking","confidence_badge","getConfidenceBadge","final_ontology_score","suitable_for","getSuitabilityText","why_recommended","getRecommendationReason","semantic_highlights","getSemanticHighlights","safety_status","semantic_safety_analysis","overall_safety_status","groupedByCategory","groupByCategory","insights","extractInsights","grouped_recommendations","profile_used","generated_at","toISOString","frontend_version","analyzeProductCompatibility","selectedProducts","_conflictAnalysis$ana","_conflictAnalysis$ana2","_conflictAnalysis$ana3","compatible","allIngredients","extractIngredientsFromProducts","conflictAnalysis","synergyAnalysis","analysis","conflict_analysis","total_conflicts","conflict_details","synergy_opportunities","findSynergiesInProducts","generateCompatibilityRecommendations","selected_products","p","id","name","brand_name","main_category","getRecommendationsByCategory","category","userProfile","ontologyResults","categoryRecommendations","filter","_product$main_categor","toLowerCase","ontology_powered","validSkinTypes","skin_type","includes","concerns","Array","isArray","sensitivities","profileChanged","JSON","stringify","cacheAge","cached_at","score","level","color","text","_product$matched_sema","_product$semantic_saf2","suitableReasons","matched_semantic_ingredients","push","join","_product$matched_sema2","reasons","ontology_explanation","ingredientNames","i","highlights","forEach","ingredient","type","benefit","function","reduce","groups","_profile$concerns","_profile$sensitivitie","algorithm_performance","processing_time","confidence","ontology_confidence","profile_analysis","concerns_count","sensitivities_count","recommendation_breakdown","top_ingredients","getTopIngredients","safety_overview","getSafetyOverview","categoryBreakdown","Object","keys","ingredientCount","entries","sort","a","b","slice","count","frequency","safetyStatus","safe","warning","conflict","unknown","_product$semantic_saf3","status","products","ingredients","Set","ingredient_list","productIngredients","split","trim","add","from","synergyData","_conflictAnalysis$ana4","_conflictAnalysis$ana5","action","clearCache","getCacheInfo","cached","isValid","age_ms","is_valid","expires_in_ms","recommendationService"],"sources":["C:/Users/msi laptop/OneDrive - Universitas Islam Indonesia/matchcare/matchCare-system3/frontend/src/services/RecommendationService.js"],"sourcesContent":["// src/services/RecommendationService.js - UPDATED FOR TRUE ONTOLOGY INTEGRATION\r\nimport { getOntologyRecommendations, analyzeIngredientConflicts, getIngredientSynergies } from './api';\r\n\r\nclass RecommendationService {\r\n  constructor() {\r\n    this.cachedRecommendations = null;\r\n    this.lastProfile = null;\r\n    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes cache\r\n  }\r\n\r\n  // ================== üß† MAIN ONTOLOGY RECOMMENDATIONS ==================\r\n\r\n  /**\r\n   * Get personalized skincare recommendations using TRUE ontology-based algorithm\r\n   * @param {Object} profile - User skin profile\r\n   * @param {string} profile.skin_type - 'normal', 'dry', 'oily', 'combination'\r\n   * @param {Array} profile.concerns - ['acne', 'wrinkles', 'dryness', etc.]\r\n   * @param {Array} profile.sensitivities - ['fragrance', 'alcohol', 'silicone']\r\n   * @returns {Promise<Object>} Ontology-based recommendations\r\n   */\r\n  async getPersonalizedRecommendations(profile, options = {}) {\r\n    try {\r\n      const { \r\n        useCache = true, \r\n        forceRefresh = false,\r\n        includeExplanation = true \r\n      } = options;\r\n\r\n      // Validate profile\r\n      if (!this.validateProfile(profile)) {\r\n        throw new Error('Invalid skin profile provided');\r\n      }\r\n\r\n      // Check cache (if enabled and not forced refresh)\r\n      if (useCache && !forceRefresh && this.isCacheValid(profile)) {\r\n        console.log('üì¶ Using cached ontology recommendations');\r\n        return this.cachedRecommendations;\r\n      }\r\n\r\n      console.log('üß† Getting fresh ontology recommendations for profile:', profile);\r\n\r\n      // Call TRUE ontology-based API\r\n      const startTime = Date.now();\r\n      const result = await getOntologyRecommendations(profile);\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      // Process and enhance recommendations\r\n      const processedRecommendations = this.processOntologyRecommendations(result, profile);\r\n\r\n      // Cache results\r\n      if (useCache) {\r\n        this.cacheRecommendations(processedRecommendations, profile);\r\n      }\r\n\r\n      console.log(`‚úÖ Ontology recommendations completed in ${responseTime}ms`);\r\n      console.log(`üéØ Found ${processedRecommendations.recommendations.length} recommendations`);\r\n\r\n      return {\r\n        success: true,\r\n        ...processedRecommendations,\r\n        performance: {\r\n          frontend_processing_time: responseTime,\r\n          backend_processing_time: result.metadata?.processing_time_ms,\r\n          total_recommendations: processedRecommendations.recommendations.length\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Personalized recommendations failed:', error);\r\n      \r\n      // Return fallback recommendations if available\r\n      if (this.cachedRecommendations) {\r\n        console.log('üîÑ Falling back to cached recommendations');\r\n        return {\r\n          success: false,\r\n          fallback: true,\r\n          error: error.message,\r\n          ...this.cachedRecommendations\r\n        };\r\n      }\r\n\r\n      throw new Error(`Failed to get personalized recommendations: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process raw ontology recommendations and add frontend enhancements\r\n   */\r\n  processOntologyRecommendations(rawResult, profile) {\r\n    const { recommendations, metadata, academic_analysis } = rawResult;\r\n\r\n    // Enhance each recommendation with UI-friendly data\r\n    const enhancedRecommendations = recommendations.map((product, index) => ({\r\n      ...product,\r\n      ui_enhancements: {\r\n        ranking: index + 1,\r\n        confidence_badge: this.getConfidenceBadge(product.final_ontology_score),\r\n        suitable_for: this.getSuitabilityText(product, profile),\r\n        why_recommended: this.getRecommendationReason(product, profile),\r\n        semantic_highlights: this.getSemanticHighlights(product),\r\n        safety_status: product.semantic_safety_analysis?.overall_safety_status || 'unknown'\r\n      }\r\n    }));\r\n\r\n    // Group recommendations by category for better UX\r\n    const groupedByCategory = this.groupByCategory(enhancedRecommendations);\r\n\r\n    // Extract key insights for dashboard\r\n    const insights = this.extractInsights(enhancedRecommendations, metadata, profile);\r\n\r\n    return {\r\n      recommendations: enhancedRecommendations,\r\n      grouped_recommendations: groupedByCategory,\r\n      insights,\r\n      metadata: {\r\n        ...metadata,\r\n        profile_used: profile,\r\n        generated_at: new Date().toISOString(),\r\n        frontend_version: '2.0.0'\r\n      },\r\n      academic_analysis\r\n    };\r\n  }\r\n\r\n  // ================== üîç ANALYSIS HELPERS ==================\r\n\r\n  /**\r\n   * Analyze ingredient compatibility for selected products\r\n   */\r\n  async analyzeProductCompatibility(selectedProducts) {\r\n    try {\r\n      if (!selectedProducts || selectedProducts.length < 2) {\r\n        return { compatible: true, message: 'Need at least 2 products to analyze compatibility' };\r\n      }\r\n\r\n      // Extract all ingredients from selected products\r\n      const allIngredients = this.extractIngredientsFromProducts(selectedProducts);\r\n      \r\n      // Analyze conflicts using ontology\r\n      const conflictAnalysis = await analyzeIngredientConflicts(allIngredients);\r\n\r\n      // Get synergies\r\n      const synergyAnalysis = await getIngredientSynergies();\r\n\r\n      return {\r\n        compatible: conflictAnalysis.analysis?.conflict_analysis?.total_conflicts === 0,\r\n        conflict_details: conflictAnalysis.analysis?.conflict_analysis,\r\n        synergy_opportunities: this.findSynergiesInProducts(selectedProducts, synergyAnalysis),\r\n        recommendations: this.generateCompatibilityRecommendations(conflictAnalysis),\r\n        selected_products: selectedProducts.map(p => ({\r\n          id: p.id,\r\n          name: p.name,\r\n          brand_name: p.brand_name,\r\n          main_category: p.main_category\r\n        }))\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Product compatibility analysis failed:', error);\r\n      return {\r\n        compatible: null,\r\n        error: error.message,\r\n        selected_products: selectedProducts\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get recommendations by category with ontology insights\r\n   */\r\n  async getRecommendationsByCategory(category, userProfile = null) {\r\n    try {\r\n      // If user profile available, use ontology recommendations and filter by category\r\n      if (userProfile) {\r\n        const ontologyResults = await this.getPersonalizedRecommendations(userProfile);\r\n        const categoryRecommendations = ontologyResults.recommendations.filter(\r\n          product => product.main_category?.toLowerCase() === category.toLowerCase()\r\n        );\r\n\r\n        return {\r\n          success: true,\r\n          category,\r\n          recommendations: categoryRecommendations,\r\n          ontology_powered: true,\r\n          insights: ontologyResults.insights\r\n        };\r\n      }\r\n\r\n      // Fallback to generic category recommendations\r\n      // This would typically call a different API endpoint\r\n      console.log(`üìÇ Getting generic recommendations for category: ${category}`);\r\n      \r\n      return {\r\n        success: true,\r\n        category,\r\n        recommendations: [],\r\n        ontology_powered: false,\r\n        message: 'Complete skin quiz for personalized ontology-based recommendations'\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(`‚ùå Category recommendations failed for ${category}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ================== üõ†Ô∏è UTILITY METHODS ==================\r\n\r\n  validateProfile(profile) {\r\n    if (!profile || typeof profile !== 'object') return false;\r\n    \r\n    const validSkinTypes = ['normal', 'dry', 'oily', 'combination'];\r\n    if (!profile.skin_type || !validSkinTypes.includes(profile.skin_type)) {\r\n      return false;\r\n    }\r\n\r\n    // Concerns and sensitivities are optional but should be arrays if provided\r\n    if (profile.concerns && !Array.isArray(profile.concerns)) return false;\r\n    if (profile.sensitivities && !Array.isArray(profile.sensitivities)) return false;\r\n\r\n    return true;\r\n  }\r\n\r\n  isCacheValid(profile) {\r\n    if (!this.cachedRecommendations || !this.lastProfile) return false;\r\n    \r\n    // Check if profile changed\r\n    const profileChanged = JSON.stringify(profile) !== JSON.stringify(this.lastProfile);\r\n    if (profileChanged) return false;\r\n\r\n    // Check cache timeout\r\n    const cacheAge = Date.now() - this.cachedRecommendations.cached_at;\r\n    return cacheAge < this.cacheTimeout;\r\n  }\r\n\r\n  cacheRecommendations(recommendations, profile) {\r\n    this.cachedRecommendations = {\r\n      ...recommendations,\r\n      cached_at: Date.now()\r\n    };\r\n    this.lastProfile = { ...profile };\r\n    console.log('üì¶ Recommendations cached for 5 minutes');\r\n  }\r\n\r\n  getConfidenceBadge(score) {\r\n    if (score >= 80) return { level: 'high', color: 'green', text: 'Highly Recommended' };\r\n    if (score >= 60) return { level: 'medium', color: 'yellow', text: 'Good Match' };\r\n    if (score >= 40) return { level: 'low', color: 'orange', text: 'Potential Match' };\r\n    return { level: 'very_low', color: 'red', text: 'Poor Match' };\r\n  }\r\n\r\n  getSuitabilityText(product, profile) {\r\n    const suitableReasons = [];\r\n    \r\n    if (product.matched_semantic_ingredients?.length > 0) {\r\n      suitableReasons.push(`Contains ${product.matched_semantic_ingredients.length} ontology-matched ingredients`);\r\n    }\r\n    \r\n    if (product.semantic_safety_analysis?.overall_safety_status === 'safe') {\r\n      suitableReasons.push('Safe ingredient combination');\r\n    }\r\n\r\n    if (suitableReasons.length === 0) {\r\n      return `Suitable for ${profile.skin_type} skin`;\r\n    }\r\n\r\n    return suitableReasons.join(' ‚Ä¢ ');\r\n  }\r\n\r\n  getRecommendationReason(product, profile) {\r\n    const reasons = [];\r\n    \r\n    // Add ontology-specific reasons\r\n    if (product.ontology_explanation) {\r\n      reasons.push(product.ontology_explanation);\r\n    }\r\n\r\n    // Add semantic ingredient reasons\r\n    if (product.matched_semantic_ingredients?.length > 0) {\r\n      const ingredientNames = product.matched_semantic_ingredients.map(i => i.name).join(', ');\r\n      reasons.push(`Key ingredients: ${ingredientNames}`);\r\n    }\r\n\r\n    return reasons.length > 0 ? reasons.join(' ‚Ä¢ ') : 'Recommended by ontology algorithm';\r\n  }\r\n\r\n  getSemanticHighlights(product) {\r\n    const highlights = [];\r\n    \r\n    if (product.matched_semantic_ingredients) {\r\n      product.matched_semantic_ingredients.forEach(ingredient => {\r\n        highlights.push({\r\n          type: 'ingredient',\r\n          name: ingredient.name,\r\n          benefit: ingredient.benefit,\r\n          function: ingredient.function\r\n        });\r\n      });\r\n    }\r\n\r\n    return highlights;\r\n  }\r\n\r\n  groupByCategory(recommendations) {\r\n    return recommendations.reduce((groups, product) => {\r\n      const category = product.main_category || 'Other';\r\n      if (!groups[category]) {\r\n        groups[category] = [];\r\n      }\r\n      groups[category].push(product);\r\n      return groups;\r\n    }, {});\r\n  }\r\n\r\n  extractInsights(recommendations, metadata, profile) {\r\n    const insights = {\r\n      total_recommendations: recommendations.length,\r\n      algorithm_performance: {\r\n        processing_time: metadata?.processing_time_ms,\r\n        confidence: metadata?.ontology_confidence\r\n      },\r\n      profile_analysis: {\r\n        skin_type: profile.skin_type,\r\n        concerns_count: profile.concerns?.length || 0,\r\n        sensitivities_count: profile.sensitivities?.length || 0\r\n      },\r\n      recommendation_breakdown: {},\r\n      top_ingredients: this.getTopIngredients(recommendations),\r\n      safety_overview: this.getSafetyOverview(recommendations)\r\n    };\r\n\r\n    // Category breakdown\r\n    const categoryBreakdown = this.groupByCategory(recommendations);\r\n    Object.keys(categoryBreakdown).forEach(category => {\r\n      insights.recommendation_breakdown[category] = categoryBreakdown[category].length;\r\n    });\r\n\r\n    return insights;\r\n  }\r\n\r\n  getTopIngredients(recommendations) {\r\n    const ingredientCount = {};\r\n    \r\n    recommendations.forEach(product => {\r\n      if (product.matched_semantic_ingredients) {\r\n        product.matched_semantic_ingredients.forEach(ingredient => {\r\n          ingredientCount[ingredient.name] = (ingredientCount[ingredient.name] || 0) + 1;\r\n        });\r\n      }\r\n    });\r\n\r\n    return Object.entries(ingredientCount)\r\n      .sort(([,a], [,b]) => b - a)\r\n      .slice(0, 5)\r\n      .map(([name, count]) => ({ name, frequency: count }));\r\n  }\r\n\r\n  getSafetyOverview(recommendations) {\r\n    const safetyStatus = {\r\n      safe: 0,\r\n      warning: 0,\r\n      conflict: 0,\r\n      unknown: 0\r\n    };\r\n\r\n    recommendations.forEach(product => {\r\n      const status = product.semantic_safety_analysis?.overall_safety_status || 'unknown';\r\n      safetyStatus[status] = (safetyStatus[status] || 0) + 1;\r\n    });\r\n\r\n    return safetyStatus;\r\n  }\r\n\r\n  extractIngredientsFromProducts(products) {\r\n    const ingredients = new Set();\r\n    \r\n    products.forEach(product => {\r\n      if (product.ingredient_list) {\r\n        // Simple ingredient extraction - could be enhanced\r\n        const productIngredients = product.ingredient_list\r\n          .split(/[,\\n]/)\r\n          .map(ingredient => ingredient.trim())\r\n          .filter(ingredient => ingredient.length > 0);\r\n        \r\n        productIngredients.forEach(ingredient => ingredients.add(ingredient));\r\n      }\r\n    });\r\n\r\n    return Array.from(ingredients).slice(0, 20); // Limit for API performance\r\n  }\r\n\r\n  findSynergiesInProducts(products, synergyData) {\r\n    // Implementation would analyze synergies between products\r\n    // For now, return placeholder\r\n    return [];\r\n  }\r\n\r\n  generateCompatibilityRecommendations(conflictAnalysis) {\r\n    const recommendations = [];\r\n    \r\n    if (conflictAnalysis.analysis?.conflict_analysis?.total_conflicts > 0) {\r\n      recommendations.push({\r\n        type: 'warning',\r\n        message: 'Some ingredients may conflict. Consider using products at different times.',\r\n        action: 'Review ingredient conflicts'\r\n      });\r\n    } else {\r\n      recommendations.push({\r\n        type: 'success',\r\n        message: 'Products appear compatible for combined use.',\r\n        action: 'Safe to use together'\r\n      });\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  // ================== üîÑ CACHE MANAGEMENT ==================\r\n\r\n  clearCache() {\r\n    this.cachedRecommendations = null;\r\n    this.lastProfile = null;\r\n    console.log('üóëÔ∏è Recommendation cache cleared');\r\n  }\r\n\r\n  getCacheInfo() {\r\n    if (!this.cachedRecommendations) {\r\n      return { cached: false };\r\n    }\r\n\r\n    const cacheAge = Date.now() - this.cachedRecommendations.cached_at;\r\n    const isValid = cacheAge < this.cacheTimeout;\r\n\r\n    return {\r\n      cached: true,\r\n      age_ms: cacheAge,\r\n      is_valid: isValid,\r\n      profile: this.lastProfile,\r\n      expires_in_ms: this.cacheTimeout - cacheAge\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nconst recommendationService = new RecommendationService();\r\nexport default recommendationService;"],"mappings":"AAAA;AACA,SAASA,0BAA0B,EAAEC,0BAA0B,EAAEC,sBAAsB,QAAQ,OAAO;AAEtG,MAAMC,qBAAqB,CAAC;EAC1BC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;EACrC;;EAEA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,8BAA8BA,CAACC,OAAO,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IAC1D,IAAI;MAAA,IAAAC,gBAAA;MACF,MAAM;QACJC,QAAQ,GAAG,IAAI;QACfC,YAAY,GAAG,KAAK;QACpBC,kBAAkB,GAAG;MACvB,CAAC,GAAGJ,OAAO;;MAEX;MACA,IAAI,CAAC,IAAI,CAACK,eAAe,CAACN,OAAO,CAAC,EAAE;QAClC,MAAM,IAAIO,KAAK,CAAC,+BAA+B,CAAC;MAClD;;MAEA;MACA,IAAIJ,QAAQ,IAAI,CAACC,YAAY,IAAI,IAAI,CAACI,YAAY,CAACR,OAAO,CAAC,EAAE;QAC3DS,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;QACvD,OAAO,IAAI,CAACd,qBAAqB;MACnC;MAEAa,OAAO,CAACC,GAAG,CAAC,wDAAwD,EAAEV,OAAO,CAAC;;MAE9E;MACA,MAAMW,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;MAC5B,MAAMC,MAAM,GAAG,MAAMvB,0BAA0B,CAACS,OAAO,CAAC;MACxD,MAAMe,YAAY,GAAGH,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS;;MAE3C;MACA,MAAMK,wBAAwB,GAAG,IAAI,CAACC,8BAA8B,CAACH,MAAM,EAAEd,OAAO,CAAC;;MAErF;MACA,IAAIG,QAAQ,EAAE;QACZ,IAAI,CAACe,oBAAoB,CAACF,wBAAwB,EAAEhB,OAAO,CAAC;MAC9D;MAEAS,OAAO,CAACC,GAAG,CAAC,2CAA2CK,YAAY,IAAI,CAAC;MACxEN,OAAO,CAACC,GAAG,CAAC,YAAYM,wBAAwB,CAACG,eAAe,CAACC,MAAM,kBAAkB,CAAC;MAE1F,OAAO;QACLC,OAAO,EAAE,IAAI;QACb,GAAGL,wBAAwB;QAC3BM,WAAW,EAAE;UACXC,wBAAwB,EAAER,YAAY;UACtCS,uBAAuB,GAAAtB,gBAAA,GAAEY,MAAM,CAACW,QAAQ,cAAAvB,gBAAA,uBAAfA,gBAAA,CAAiBwB,kBAAkB;UAC5DC,qBAAqB,EAAEX,wBAAwB,CAACG,eAAe,CAACC;QAClE;MACF,CAAC;IAEH,CAAC,CAAC,OAAOQ,KAAK,EAAE;MACdnB,OAAO,CAACmB,KAAK,CAAC,wCAAwC,EAAEA,KAAK,CAAC;;MAE9D;MACA,IAAI,IAAI,CAAChC,qBAAqB,EAAE;QAC9Ba,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;QACxD,OAAO;UACLW,OAAO,EAAE,KAAK;UACdQ,QAAQ,EAAE,IAAI;UACdD,KAAK,EAAEA,KAAK,CAACE,OAAO;UACpB,GAAG,IAAI,CAAClC;QACV,CAAC;MACH;MAEA,MAAM,IAAIW,KAAK,CAAC,+CAA+CqB,KAAK,CAACE,OAAO,EAAE,CAAC;IACjF;EACF;;EAEA;AACF;AACA;EACEb,8BAA8BA,CAACc,SAAS,EAAE/B,OAAO,EAAE;IACjD,MAAM;MAAEmB,eAAe;MAAEM,QAAQ;MAAEO;IAAkB,CAAC,GAAGD,SAAS;;IAElE;IACA,MAAME,uBAAuB,GAAGd,eAAe,CAACe,GAAG,CAAC,CAACC,OAAO,EAAEC,KAAK;MAAA,IAAAC,qBAAA;MAAA,OAAM;QACvE,GAAGF,OAAO;QACVG,eAAe,EAAE;UACfC,OAAO,EAAEH,KAAK,GAAG,CAAC;UAClBI,gBAAgB,EAAE,IAAI,CAACC,kBAAkB,CAACN,OAAO,CAACO,oBAAoB,CAAC;UACvEC,YAAY,EAAE,IAAI,CAACC,kBAAkB,CAACT,OAAO,EAAEnC,OAAO,CAAC;UACvD6C,eAAe,EAAE,IAAI,CAACC,uBAAuB,CAACX,OAAO,EAAEnC,OAAO,CAAC;UAC/D+C,mBAAmB,EAAE,IAAI,CAACC,qBAAqB,CAACb,OAAO,CAAC;UACxDc,aAAa,EAAE,EAAAZ,qBAAA,GAAAF,OAAO,CAACe,wBAAwB,cAAAb,qBAAA,uBAAhCA,qBAAA,CAAkCc,qBAAqB,KAAI;QAC5E;MACF,CAAC;IAAA,CAAC,CAAC;;IAEH;IACA,MAAMC,iBAAiB,GAAG,IAAI,CAACC,eAAe,CAACpB,uBAAuB,CAAC;;IAEvE;IACA,MAAMqB,QAAQ,GAAG,IAAI,CAACC,eAAe,CAACtB,uBAAuB,EAAER,QAAQ,EAAEzB,OAAO,CAAC;IAEjF,OAAO;MACLmB,eAAe,EAAEc,uBAAuB;MACxCuB,uBAAuB,EAAEJ,iBAAiB;MAC1CE,QAAQ;MACR7B,QAAQ,EAAE;QACR,GAAGA,QAAQ;QACXgC,YAAY,EAAEzD,OAAO;QACrB0D,YAAY,EAAE,IAAI9C,IAAI,CAAC,CAAC,CAAC+C,WAAW,CAAC,CAAC;QACtCC,gBAAgB,EAAE;MACpB,CAAC;MACD5B;IACF,CAAC;EACH;;EAEA;;EAEA;AACF;AACA;EACE,MAAM6B,2BAA2BA,CAACC,gBAAgB,EAAE;IAClD,IAAI;MAAA,IAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA;MACF,IAAI,CAACH,gBAAgB,IAAIA,gBAAgB,CAAC1C,MAAM,GAAG,CAAC,EAAE;QACpD,OAAO;UAAE8C,UAAU,EAAE,IAAI;UAAEpC,OAAO,EAAE;QAAoD,CAAC;MAC3F;;MAEA;MACA,MAAMqC,cAAc,GAAG,IAAI,CAACC,8BAA8B,CAACN,gBAAgB,CAAC;;MAE5E;MACA,MAAMO,gBAAgB,GAAG,MAAM7E,0BAA0B,CAAC2E,cAAc,CAAC;;MAEzE;MACA,MAAMG,eAAe,GAAG,MAAM7E,sBAAsB,CAAC,CAAC;MAEtD,OAAO;QACLyE,UAAU,EAAE,EAAAH,qBAAA,GAAAM,gBAAgB,CAACE,QAAQ,cAAAR,qBAAA,wBAAAC,sBAAA,GAAzBD,qBAAA,CAA2BS,iBAAiB,cAAAR,sBAAA,uBAA5CA,sBAAA,CAA8CS,eAAe,MAAK,CAAC;QAC/EC,gBAAgB,GAAAT,sBAAA,GAAEI,gBAAgB,CAACE,QAAQ,cAAAN,sBAAA,uBAAzBA,sBAAA,CAA2BO,iBAAiB;QAC9DG,qBAAqB,EAAE,IAAI,CAACC,uBAAuB,CAACd,gBAAgB,EAAEQ,eAAe,CAAC;QACtFnD,eAAe,EAAE,IAAI,CAAC0D,oCAAoC,CAACR,gBAAgB,CAAC;QAC5ES,iBAAiB,EAAEhB,gBAAgB,CAAC5B,GAAG,CAAC6C,CAAC,KAAK;UAC5CC,EAAE,EAAED,CAAC,CAACC,EAAE;UACRC,IAAI,EAAEF,CAAC,CAACE,IAAI;UACZC,UAAU,EAAEH,CAAC,CAACG,UAAU;UACxBC,aAAa,EAAEJ,CAAC,CAACI;QACnB,CAAC,CAAC;MACJ,CAAC;IAEH,CAAC,CAAC,OAAOvD,KAAK,EAAE;MACdnB,OAAO,CAACmB,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;MAChE,OAAO;QACLsC,UAAU,EAAE,IAAI;QAChBtC,KAAK,EAAEA,KAAK,CAACE,OAAO;QACpBgD,iBAAiB,EAAEhB;MACrB,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACE,MAAMsB,4BAA4BA,CAACC,QAAQ,EAAEC,WAAW,GAAG,IAAI,EAAE;IAC/D,IAAI;MACF;MACA,IAAIA,WAAW,EAAE;QACf,MAAMC,eAAe,GAAG,MAAM,IAAI,CAACxF,8BAA8B,CAACuF,WAAW,CAAC;QAC9E,MAAME,uBAAuB,GAAGD,eAAe,CAACpE,eAAe,CAACsE,MAAM,CACpEtD,OAAO;UAAA,IAAAuD,qBAAA;UAAA,OAAI,EAAAA,qBAAA,GAAAvD,OAAO,CAACgD,aAAa,cAAAO,qBAAA,uBAArBA,qBAAA,CAAuBC,WAAW,CAAC,CAAC,MAAKN,QAAQ,CAACM,WAAW,CAAC,CAAC;QAAA,CAC5E,CAAC;QAED,OAAO;UACLtE,OAAO,EAAE,IAAI;UACbgE,QAAQ;UACRlE,eAAe,EAAEqE,uBAAuB;UACxCI,gBAAgB,EAAE,IAAI;UACtBtC,QAAQ,EAAEiC,eAAe,CAACjC;QAC5B,CAAC;MACH;;MAEA;MACA;MACA7C,OAAO,CAACC,GAAG,CAAC,oDAAoD2E,QAAQ,EAAE,CAAC;MAE3E,OAAO;QACLhE,OAAO,EAAE,IAAI;QACbgE,QAAQ;QACRlE,eAAe,EAAE,EAAE;QACnByE,gBAAgB,EAAE,KAAK;QACvB9D,OAAO,EAAE;MACX,CAAC;IAEH,CAAC,CAAC,OAAOF,KAAK,EAAE;MACdnB,OAAO,CAACmB,KAAK,CAAC,yCAAyCyD,QAAQ,GAAG,EAAEzD,KAAK,CAAC;MAC1E,MAAMA,KAAK;IACb;EACF;;EAEA;;EAEAtB,eAAeA,CAACN,OAAO,EAAE;IACvB,IAAI,CAACA,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE,OAAO,KAAK;IAEzD,MAAM6F,cAAc,GAAG,CAAC,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,aAAa,CAAC;IAC/D,IAAI,CAAC7F,OAAO,CAAC8F,SAAS,IAAI,CAACD,cAAc,CAACE,QAAQ,CAAC/F,OAAO,CAAC8F,SAAS,CAAC,EAAE;MACrE,OAAO,KAAK;IACd;;IAEA;IACA,IAAI9F,OAAO,CAACgG,QAAQ,IAAI,CAACC,KAAK,CAACC,OAAO,CAAClG,OAAO,CAACgG,QAAQ,CAAC,EAAE,OAAO,KAAK;IACtE,IAAIhG,OAAO,CAACmG,aAAa,IAAI,CAACF,KAAK,CAACC,OAAO,CAAClG,OAAO,CAACmG,aAAa,CAAC,EAAE,OAAO,KAAK;IAEhF,OAAO,IAAI;EACb;EAEA3F,YAAYA,CAACR,OAAO,EAAE;IACpB,IAAI,CAAC,IAAI,CAACJ,qBAAqB,IAAI,CAAC,IAAI,CAACC,WAAW,EAAE,OAAO,KAAK;;IAElE;IACA,MAAMuG,cAAc,GAAGC,IAAI,CAACC,SAAS,CAACtG,OAAO,CAAC,KAAKqG,IAAI,CAACC,SAAS,CAAC,IAAI,CAACzG,WAAW,CAAC;IACnF,IAAIuG,cAAc,EAAE,OAAO,KAAK;;IAEhC;IACA,MAAMG,QAAQ,GAAG3F,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACjB,qBAAqB,CAAC4G,SAAS;IAClE,OAAOD,QAAQ,GAAG,IAAI,CAACzG,YAAY;EACrC;EAEAoB,oBAAoBA,CAACC,eAAe,EAAEnB,OAAO,EAAE;IAC7C,IAAI,CAACJ,qBAAqB,GAAG;MAC3B,GAAGuB,eAAe;MAClBqF,SAAS,EAAE5F,IAAI,CAACC,GAAG,CAAC;IACtB,CAAC;IACD,IAAI,CAAChB,WAAW,GAAG;MAAE,GAAGG;IAAQ,CAAC;IACjCS,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;EACxD;EAEA+B,kBAAkBA,CAACgE,KAAK,EAAE;IACxB,IAAIA,KAAK,IAAI,EAAE,EAAE,OAAO;MAAEC,KAAK,EAAE,MAAM;MAAEC,KAAK,EAAE,OAAO;MAAEC,IAAI,EAAE;IAAqB,CAAC;IACrF,IAAIH,KAAK,IAAI,EAAE,EAAE,OAAO;MAAEC,KAAK,EAAE,QAAQ;MAAEC,KAAK,EAAE,QAAQ;MAAEC,IAAI,EAAE;IAAa,CAAC;IAChF,IAAIH,KAAK,IAAI,EAAE,EAAE,OAAO;MAAEC,KAAK,EAAE,KAAK;MAAEC,KAAK,EAAE,QAAQ;MAAEC,IAAI,EAAE;IAAkB,CAAC;IAClF,OAAO;MAAEF,KAAK,EAAE,UAAU;MAAEC,KAAK,EAAE,KAAK;MAAEC,IAAI,EAAE;IAAa,CAAC;EAChE;EAEAhE,kBAAkBA,CAACT,OAAO,EAAEnC,OAAO,EAAE;IAAA,IAAA6G,qBAAA,EAAAC,sBAAA;IACnC,MAAMC,eAAe,GAAG,EAAE;IAE1B,IAAI,EAAAF,qBAAA,GAAA1E,OAAO,CAAC6E,4BAA4B,cAAAH,qBAAA,uBAApCA,qBAAA,CAAsCzF,MAAM,IAAG,CAAC,EAAE;MACpD2F,eAAe,CAACE,IAAI,CAAC,YAAY9E,OAAO,CAAC6E,4BAA4B,CAAC5F,MAAM,+BAA+B,CAAC;IAC9G;IAEA,IAAI,EAAA0F,sBAAA,GAAA3E,OAAO,CAACe,wBAAwB,cAAA4D,sBAAA,uBAAhCA,sBAAA,CAAkC3D,qBAAqB,MAAK,MAAM,EAAE;MACtE4D,eAAe,CAACE,IAAI,CAAC,6BAA6B,CAAC;IACrD;IAEA,IAAIF,eAAe,CAAC3F,MAAM,KAAK,CAAC,EAAE;MAChC,OAAO,gBAAgBpB,OAAO,CAAC8F,SAAS,OAAO;IACjD;IAEA,OAAOiB,eAAe,CAACG,IAAI,CAAC,KAAK,CAAC;EACpC;EAEApE,uBAAuBA,CAACX,OAAO,EAAEnC,OAAO,EAAE;IAAA,IAAAmH,sBAAA;IACxC,MAAMC,OAAO,GAAG,EAAE;;IAElB;IACA,IAAIjF,OAAO,CAACkF,oBAAoB,EAAE;MAChCD,OAAO,CAACH,IAAI,CAAC9E,OAAO,CAACkF,oBAAoB,CAAC;IAC5C;;IAEA;IACA,IAAI,EAAAF,sBAAA,GAAAhF,OAAO,CAAC6E,4BAA4B,cAAAG,sBAAA,uBAApCA,sBAAA,CAAsC/F,MAAM,IAAG,CAAC,EAAE;MACpD,MAAMkG,eAAe,GAAGnF,OAAO,CAAC6E,4BAA4B,CAAC9E,GAAG,CAACqF,CAAC,IAAIA,CAAC,CAACtC,IAAI,CAAC,CAACiC,IAAI,CAAC,IAAI,CAAC;MACxFE,OAAO,CAACH,IAAI,CAAC,oBAAoBK,eAAe,EAAE,CAAC;IACrD;IAEA,OAAOF,OAAO,CAAChG,MAAM,GAAG,CAAC,GAAGgG,OAAO,CAACF,IAAI,CAAC,KAAK,CAAC,GAAG,mCAAmC;EACvF;EAEAlE,qBAAqBA,CAACb,OAAO,EAAE;IAC7B,MAAMqF,UAAU,GAAG,EAAE;IAErB,IAAIrF,OAAO,CAAC6E,4BAA4B,EAAE;MACxC7E,OAAO,CAAC6E,4BAA4B,CAACS,OAAO,CAACC,UAAU,IAAI;QACzDF,UAAU,CAACP,IAAI,CAAC;UACdU,IAAI,EAAE,YAAY;UAClB1C,IAAI,EAAEyC,UAAU,CAACzC,IAAI;UACrB2C,OAAO,EAAEF,UAAU,CAACE,OAAO;UAC3BC,QAAQ,EAAEH,UAAU,CAACG;QACvB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IAEA,OAAOL,UAAU;EACnB;EAEAnE,eAAeA,CAAClC,eAAe,EAAE;IAC/B,OAAOA,eAAe,CAAC2G,MAAM,CAAC,CAACC,MAAM,EAAE5F,OAAO,KAAK;MACjD,MAAMkD,QAAQ,GAAGlD,OAAO,CAACgD,aAAa,IAAI,OAAO;MACjD,IAAI,CAAC4C,MAAM,CAAC1C,QAAQ,CAAC,EAAE;QACrB0C,MAAM,CAAC1C,QAAQ,CAAC,GAAG,EAAE;MACvB;MACA0C,MAAM,CAAC1C,QAAQ,CAAC,CAAC4B,IAAI,CAAC9E,OAAO,CAAC;MAC9B,OAAO4F,MAAM;IACf,CAAC,EAAE,CAAC,CAAC,CAAC;EACR;EAEAxE,eAAeA,CAACpC,eAAe,EAAEM,QAAQ,EAAEzB,OAAO,EAAE;IAAA,IAAAgI,iBAAA,EAAAC,qBAAA;IAClD,MAAM3E,QAAQ,GAAG;MACf3B,qBAAqB,EAAER,eAAe,CAACC,MAAM;MAC7C8G,qBAAqB,EAAE;QACrBC,eAAe,EAAE1G,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEC,kBAAkB;QAC7C0G,UAAU,EAAE3G,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE4G;MACxB,CAAC;MACDC,gBAAgB,EAAE;QAChBxC,SAAS,EAAE9F,OAAO,CAAC8F,SAAS;QAC5ByC,cAAc,EAAE,EAAAP,iBAAA,GAAAhI,OAAO,CAACgG,QAAQ,cAAAgC,iBAAA,uBAAhBA,iBAAA,CAAkB5G,MAAM,KAAI,CAAC;QAC7CoH,mBAAmB,EAAE,EAAAP,qBAAA,GAAAjI,OAAO,CAACmG,aAAa,cAAA8B,qBAAA,uBAArBA,qBAAA,CAAuB7G,MAAM,KAAI;MACxD,CAAC;MACDqH,wBAAwB,EAAE,CAAC,CAAC;MAC5BC,eAAe,EAAE,IAAI,CAACC,iBAAiB,CAACxH,eAAe,CAAC;MACxDyH,eAAe,EAAE,IAAI,CAACC,iBAAiB,CAAC1H,eAAe;IACzD,CAAC;;IAED;IACA,MAAM2H,iBAAiB,GAAG,IAAI,CAACzF,eAAe,CAAClC,eAAe,CAAC;IAC/D4H,MAAM,CAACC,IAAI,CAACF,iBAAiB,CAAC,CAACrB,OAAO,CAACpC,QAAQ,IAAI;MACjD/B,QAAQ,CAACmF,wBAAwB,CAACpD,QAAQ,CAAC,GAAGyD,iBAAiB,CAACzD,QAAQ,CAAC,CAACjE,MAAM;IAClF,CAAC,CAAC;IAEF,OAAOkC,QAAQ;EACjB;EAEAqF,iBAAiBA,CAACxH,eAAe,EAAE;IACjC,MAAM8H,eAAe,GAAG,CAAC,CAAC;IAE1B9H,eAAe,CAACsG,OAAO,CAACtF,OAAO,IAAI;MACjC,IAAIA,OAAO,CAAC6E,4BAA4B,EAAE;QACxC7E,OAAO,CAAC6E,4BAA4B,CAACS,OAAO,CAACC,UAAU,IAAI;UACzDuB,eAAe,CAACvB,UAAU,CAACzC,IAAI,CAAC,GAAG,CAACgE,eAAe,CAACvB,UAAU,CAACzC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;QAChF,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IAEF,OAAO8D,MAAM,CAACG,OAAO,CAACD,eAAe,CAAC,CACnCE,IAAI,CAAC,CAAC,GAAEC,CAAC,CAAC,EAAE,GAAEC,CAAC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC,CAC3BE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CACXpH,GAAG,CAAC,CAAC,CAAC+C,IAAI,EAAEsE,KAAK,CAAC,MAAM;MAAEtE,IAAI;MAAEuE,SAAS,EAAED;IAAM,CAAC,CAAC,CAAC;EACzD;EAEAV,iBAAiBA,CAAC1H,eAAe,EAAE;IACjC,MAAMsI,YAAY,GAAG;MACnBC,IAAI,EAAE,CAAC;MACPC,OAAO,EAAE,CAAC;MACVC,QAAQ,EAAE,CAAC;MACXC,OAAO,EAAE;IACX,CAAC;IAED1I,eAAe,CAACsG,OAAO,CAACtF,OAAO,IAAI;MAAA,IAAA2H,sBAAA;MACjC,MAAMC,MAAM,GAAG,EAAAD,sBAAA,GAAA3H,OAAO,CAACe,wBAAwB,cAAA4G,sBAAA,uBAAhCA,sBAAA,CAAkC3G,qBAAqB,KAAI,SAAS;MACnFsG,YAAY,CAACM,MAAM,CAAC,GAAG,CAACN,YAAY,CAACM,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;IACxD,CAAC,CAAC;IAEF,OAAON,YAAY;EACrB;EAEArF,8BAA8BA,CAAC4F,QAAQ,EAAE;IACvC,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;IAE7BF,QAAQ,CAACvC,OAAO,CAACtF,OAAO,IAAI;MAC1B,IAAIA,OAAO,CAACgI,eAAe,EAAE;QAC3B;QACA,MAAMC,kBAAkB,GAAGjI,OAAO,CAACgI,eAAe,CAC/CE,KAAK,CAAC,OAAO,CAAC,CACdnI,GAAG,CAACwF,UAAU,IAAIA,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,CACpC7E,MAAM,CAACiC,UAAU,IAAIA,UAAU,CAACtG,MAAM,GAAG,CAAC,CAAC;QAE9CgJ,kBAAkB,CAAC3C,OAAO,CAACC,UAAU,IAAIuC,WAAW,CAACM,GAAG,CAAC7C,UAAU,CAAC,CAAC;MACvE;IACF,CAAC,CAAC;IAEF,OAAOzB,KAAK,CAACuE,IAAI,CAACP,WAAW,CAAC,CAACX,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;EAC/C;EAEA1E,uBAAuBA,CAACoF,QAAQ,EAAES,WAAW,EAAE;IAC7C;IACA;IACA,OAAO,EAAE;EACX;EAEA5F,oCAAoCA,CAACR,gBAAgB,EAAE;IAAA,IAAAqG,sBAAA,EAAAC,sBAAA;IACrD,MAAMxJ,eAAe,GAAG,EAAE;IAE1B,IAAI,EAAAuJ,sBAAA,GAAArG,gBAAgB,CAACE,QAAQ,cAAAmG,sBAAA,wBAAAC,sBAAA,GAAzBD,sBAAA,CAA2BlG,iBAAiB,cAAAmG,sBAAA,uBAA5CA,sBAAA,CAA8ClG,eAAe,IAAG,CAAC,EAAE;MACrEtD,eAAe,CAAC8F,IAAI,CAAC;QACnBU,IAAI,EAAE,SAAS;QACf7F,OAAO,EAAE,4EAA4E;QACrF8I,MAAM,EAAE;MACV,CAAC,CAAC;IACJ,CAAC,MAAM;MACLzJ,eAAe,CAAC8F,IAAI,CAAC;QACnBU,IAAI,EAAE,SAAS;QACf7F,OAAO,EAAE,8CAA8C;QACvD8I,MAAM,EAAE;MACV,CAAC,CAAC;IACJ;IAEA,OAAOzJ,eAAe;EACxB;;EAEA;;EAEA0J,UAAUA,CAAA,EAAG;IACX,IAAI,CAACjL,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACC,WAAW,GAAG,IAAI;IACvBY,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;EACjD;EAEAoK,YAAYA,CAAA,EAAG;IACb,IAAI,CAAC,IAAI,CAAClL,qBAAqB,EAAE;MAC/B,OAAO;QAAEmL,MAAM,EAAE;MAAM,CAAC;IAC1B;IAEA,MAAMxE,QAAQ,GAAG3F,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACjB,qBAAqB,CAAC4G,SAAS;IAClE,MAAMwE,OAAO,GAAGzE,QAAQ,GAAG,IAAI,CAACzG,YAAY;IAE5C,OAAO;MACLiL,MAAM,EAAE,IAAI;MACZE,MAAM,EAAE1E,QAAQ;MAChB2E,QAAQ,EAAEF,OAAO;MACjBhL,OAAO,EAAE,IAAI,CAACH,WAAW;MACzBsL,aAAa,EAAE,IAAI,CAACrL,YAAY,GAAGyG;IACrC,CAAC;EACH;AACF;;AAEA;AACA,MAAM6E,qBAAqB,GAAG,IAAI1L,qBAAqB,CAAC,CAAC;AACzD,eAAe0L,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}